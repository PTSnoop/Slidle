<html>
<head>
<meta name="viewport" content="width=440,initial-scale=0.9,user-scalable=no">
<style>
body {
	touch-action: none;
}
.footer {
   position: fixed;
   left: 0;
   bottom: 0;
   width: 100%;
   text-align: center;
}
</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/seedrandom/3.0.5/seedrandom.min.js"></script>
<script src="wordlist.js"></script>
<script>

class Box {
	constructor(letter) {
		this.letter = letter;
		this.colour = "#ccc";
	}
}
function b(x) { return new Box(x); }

var time;
var lastTime;
var ctx;
var boxes;
var memories;
var answer;
var answerSet;

var allValids = legitWords + guesses;

var boxSize = 50;
var boxMargin = 10;

function getOverlapIndices(word1, word2) {
	var word1OverlapIndex = -1;
	var word2OverlapIndex = -1;
	for (let i=0;i<word1.length;i++) {
		for (let j=0;j<word2.length;j++) {
			if (word1[i] == word2[j]) {
				return [i,j];
			}
		}
	}
	return [0,0];
}

function init() {
	ctx = document.getElementById("squares").getContext("2d");
	boxes = 
	[
		[b("A"),b("B"),b("C"),b("D"),b("E")],
		[b("F"),b("G"),b("H"),b("I"),b("J")],
		[b("K"),b("L"),b("M"),b("N"),b("O")],
		[b("P"),b("R"),b("S"),b("T"),b("U")],
		[b("V"),b("W"),b("X"),b("Y"),b("Z")],
	];

	memories = 
	[
		[{},{},{},{},{}],
		[{},{},{},{},{}],
		[{},{},{},{},{}],
		[{},{},{},{},{}],
		[{},{},{},{},{}]
	];

	//var rng = new Math.seedrandom(new Date().toJSON().slice(0,10));
	var rng = new Math.seedrandom();

	var word1;
	var word2;
	while (true) {
		word1 = legitWords[Math.abs(rng.int32()) % legitWords.length];
		word2 = legitWords[Math.abs(rng.int32()) % legitWords.length];
		console.log(word1,word2);

		var set1 = new Set(word1);
		var set2 = new Set(word2);

		// check that words don't have duplicate letters
		if (word1.length != set1.size) continue;
		if (word2.length != set2.size) continue;

		// make sure there's only one overlapping letter
		var wordboth = word1+word2;
		answerSet = new Set(wordboth);
		if (wordboth.length != answerSet.size + 1) continue;

		// no q
		if (word1.includes("q")) continue;
		if (word2.includes("q")) continue;

		// if we've made it here, we've got a workable solution
		break;
	}

	var indices = getOverlapIndices(word1, word2);

	answer = 
	[
		[b(""),b(""),b(""),b(""),b("")],
		[b(""),b(""),b(""),b(""),b("")],
		[b(""),b(""),b(""),b(""),b("")],
		[b(""),b(""),b(""),b(""),b("")],
		[b(""),b(""),b(""),b(""),b("")],
	];

	for (let i=0; i<word2.length; i++) {
		answer[indices[0]][i].letter = word2[i];
	}
	for (let i=0; i<word1.length; i++) {
		answer[i][indices[1]].letter = word1[i];
	}

	draw();
}

var clickX;
var clickY;
var mouseX;
var mouseY;
var mouseIsDown;
var columnlock;
var rowlock;
onmousemove = function(e) {
	if (e.touches) {
		mouseX = e.touches[0].clientX;
		mouseY = e.touches[0].clientY;
	} else {
		mouseX = e.clientX;
		mouseY = e.clientY;
	}
	drawframes = 60;
	draw();
}
onmouseup = function(e) {
	mouseIsDown = false;
	drawframes = 60;
	draw();
}

var boxClickedX;
var boxClickedY;
var drawframes = 60;
onmousedown = function(e) {
	console.log("Down");
	columnLock = false;
	rowLock = false;
	var squaresCanvas = document.getElementById("squares");
	if (e.path[0] != squaresCanvas) return;

	mouseIsDown = true;
	if (e.touches) {
		clickX = e.touches[0].clientX;
		clickY = e.touches[0].clientY;
	} else {
		clickX = e.clientX;
		clickY = e.clientY;
	}

	var rect = squaresCanvas.getBoundingClientRect();
	var canvasX = clickX - rect.left;
	var canvasY = clickY - rect.top;

	boxClickedX = Math.floor(canvasX / (boxSize + boxMargin)) - 1;
	boxClickedY = Math.floor(canvasY / (boxSize + boxMargin)) - 1;

	if (boxClickedX < 0 || boxClickedY < 0 || boxClickedX > 4 || boxClickedY > 4) {
		mouseIsDown = false;
		boxClickedX = 0;
		boxClickedY = 0;
	}

	mouseX = clickX;
	mouseY = clickY;

	drawframes = 60;
	draw();
}

ontouchstart = onmousedown;
ontouchend = onmouseup;
ontouchmove = onmousemove;

var lastTime;
var mouseWasDown;

function colourFromMemory(i,j) {
	var thisBox = boxes[i][j];
	var thisLetter = thisBox.letter.toLowerCase();
	var memory = memories[i][j][thisLetter];
	if (memory) {
		thisBox.colour = memory;
	}
}

function recolour(i,j) {
	var thisAnswer = answer[i][j];
	var thisBox = boxes[i][j];
	var thisLetter = thisBox.letter.toLowerCase();

	if (thisAnswer.letter == thisLetter) {
		thisBox.colour = "#2aa617";

		for (let k=0; k<boxes.length; k++) {
			for (let l=0; l<boxes.length; l++) {
				memories[k][l][thisLetter] = "#333";
			}
		}
		for (let k=0; k<boxes.length; k++) {
			memories[i][k][thisLetter] = "#ecc61d";
		}
		for (let k=0; k<boxes.length; k++) {
			memories[k][j][thisLetter] = "#ec721d";
		}
		memories[i][j][thisLetter] = thisBox.colour;
		return;
	}

	for (let k=0; k<boxes.length;k++) {
		if (answer[i][k].letter == thisLetter) {
			thisBox.colour = "#ecc61d"; // orange
			for (let q=0; q<boxes.length; q++) {
				memories[q][j][thisLetter] = "#333";
			}
			memories[i][j][thisLetter] = thisBox.colour;
			return;
		}
	}
	for (let k=0; k<boxes.length;k++) {
		if (answer[k][j].letter == thisLetter) {
			thisBox.colour = "#ec721d"; // yellow
			for (let q=0; q<boxes.length; q++) {
				memories[i][q][thisLetter] = "#333";
			}
			memories[i][j][thisLetter] = thisBox.colour;
			return;
		}
	}
	thisBox.colour = "#333";
	for (let k=0; k<boxes.length;k++) {
		if (!memories[i][k][thisLetter])
			memories[i][k][thisLetter] = "#777";
		if (!memories[k][j][thisLetter])
			memories[k][j][thisLetter] = "#777";
	}
	memories[i][j][thisLetter] = "#333";
}

function checkRow(y) {
	var word = "";
	for (let i=0; i<boxes.length; i++) {
		word += boxes[y][i].letter;
	}
	word = word.toLowerCase();
	console.log(word);
	if (allValids.includes(word)) {
		console.log("Legit!");
		return word;
	}
	return "";
}
function checkCol(x) {
	var word = "";
	for (let i=0; i<boxes.length; i++) {
		word += boxes[i][x].letter;
	}
	word = word.toLowerCase();
	console.log(word);
	if (allValids.includes(word)) {
		return word;
	}
	return "";
}

var photo = 0;
var takenPhotos = new Set();
function update() {
	/*
	var dt = (Date.now() - lastTime) / 1000;
	lastTime = Date.now();
	if (isNaN(dt))
	{
		return;
	};
   */

	if (mouseWasDown && !mouseIsDown) {
		// handle mouse-unclicked things

		if (rowlock) {
			// check the row that just moved
			var checkedRow = checkRow(boxClickedY);
			console.log("",checkedRow);
			if (checkedRow) {
				checkedRow += "r" + boxClickedY;
				if (!takenPhotos.has(checkedRow)) {
					photo = 5;
				}
				takenPhotos.add(checkedRow);
				for (let i=0; i<boxes.length; i++) {
					recolour(boxClickedY,i);
				}
			} else {
				for (let i=0; i<boxes.length; i++) {
					boxes[boxClickedY][i].colour = "#ccc";
				}
			}
			// check the columns
			for (let i=0; i<boxes.length; i++) {
				var checkedCol = checkCol(i);
				if (checkedCol) {
					checkedCol += "c" + i;
					if (!takenPhotos.has(checkedCol)) {
						photo = 5;
					}
					takenPhotos.add(checkedCol);
					for (let k=0; k<boxes.length; k++) {
						recolour(k,i);
					}
				}
			}
		}
		else if (columnlock) {
			// check the column that just moved
			var checkedCol = checkCol(boxClickedX);
			if (checkedCol) {
				checkedCol += "c" + boxClickedX;
				if (!takenPhotos.has(checkedCol)) {
					photo = 5;
				}
				takenPhotos.add(checkedCol);
				for (let i=0; i<boxes.length; i++) {
					recolour(i,boxClickedX);
				}
			} else {
				for (let i=0; i<boxes.length; i++) {
					boxes[i][boxClickedX].colour = "#ccc";
				}
			}
			// check the rows
			for (let i=0; i<boxes.length; i++) {
				var checkedRow = checkRow(i);
				if (checkedRow) {
					checkedRow += "r" + i;
					if (!takenPhotos.has(checkedRow)) {
						photo = 5;
					}
					takenPhotos.add(checkedRow);
					for (let k=0; k<boxes.length; k++) {
						recolour(i,k);
					}
				}
			}
		}

		for (let i=0; i<boxes.length; i++) {
			for (let j=0; j<boxes.length; j++) {
				colourFromMemory(i,j);
			}
		}


		rowlock = false;
		columnlock = false;
	}
	mouseWasDown = mouseIsDown;

	if (photo > 0) {
		console.log(photo);
		photo--;
		if (photo == 1) {
			photo = 0;
			console.log("Photo!");
			var squares = document.getElementById("squares");
			var history = document.getElementById("history");
			var newCanvas = document.createElement("canvas");
			newCanvas = history.appendChild(newCanvas);
			newCanvas.setAttribute("width","240");
			newCanvas.setAttribute("height","240");
			newCanvas.getContext("2d").drawImage(squares,0,0,240,240);
		}
	}

	if (mouseIsDown && !columnlock && !rowlock) {
		if (Math.abs(clickX-mouseX) > 0.2*boxSize) {
			rowlock = true;
		}
		else if (Math.abs(clickY-mouseY) > 0.2*boxSize) {
			columnlock = true;
		}
	}

	if (columnlock) {
		yNudge = mouseY - clickY;
		while (yNudge > 0.6*boxSize) {
			clickY += boxSize + boxMargin;
			var jumpbox = boxes[4][boxClickedX];
			boxes[4][boxClickedX] = boxes[3][boxClickedX];
			boxes[3][boxClickedX] = boxes[2][boxClickedX];
			boxes[2][boxClickedX] = boxes[1][boxClickedX];
			boxes[1][boxClickedX] = boxes[0][boxClickedX];
			boxes[0][boxClickedX] = jumpbox;
			yNudge = mouseY - clickY;
		}
		while (yNudge < -0.6*boxSize) {
			clickY -= boxSize + boxMargin;
			var jumpbox = boxes[0][boxClickedX];
			boxes[0][boxClickedX] = boxes[1][boxClickedX];
			boxes[1][boxClickedX] = boxes[2][boxClickedX];
			boxes[2][boxClickedX] = boxes[3][boxClickedX];
			boxes[3][boxClickedX] = boxes[4][boxClickedX];
			boxes[4][boxClickedX] = jumpbox;
			yNudge = mouseY - clickY;
		}
	}
	else if (rowlock) {
		xNudge = mouseX - clickX;
		while (xNudge > 0.6*boxSize) {
			clickX += boxSize + boxMargin;
			var jumpbox = boxes[boxClickedY][4];
			boxes[boxClickedY][4] = boxes[boxClickedY][3];
			boxes[boxClickedY][3] = boxes[boxClickedY][2];
			boxes[boxClickedY][2] = boxes[boxClickedY][1];
			boxes[boxClickedY][1] = boxes[boxClickedY][0];
			boxes[boxClickedY][0] = jumpbox;
			xNudge = mouseX - clickX;
		}
		while (xNudge < -0.6*boxSize) {
			clickX -= boxSize + boxMargin;
			var jumpbox = boxes[boxClickedY][0];
			boxes[boxClickedY][0] = boxes[boxClickedY][1];
			boxes[boxClickedY][1] = boxes[boxClickedY][2];
			boxes[boxClickedY][2] = boxes[boxClickedY][3];
			boxes[boxClickedY][3] = boxes[boxClickedY][4];
			boxes[boxClickedY][4] = jumpbox;
			xNudge = mouseX - clickX;
		}
	}
}

var lastDrawRequestId = 0;
function draw() {
	
	update();

	ctx.fillStyle = "white";
	ctx.fillRect(0,0,ctx.canvas.width, ctx.canvas.height);

	for (let y=0; y<boxes.length;++y) {
		for (let x=0; x<boxes[y].length;++x) {

			var xPos = (x+1)*(boxSize+boxMargin);
			var yPos = (y+1)*(boxSize+boxMargin);

			var xNudge = 0;
			var yNudge = 0;

			if (columnlock && x == boxClickedX) {
				yNudge = mouseY - clickY;
			}
			if (rowlock && y == boxClickedY) {
				xNudge = mouseX - clickX;
			}

			ctx.font = "bold 32px Arial";
			ctx.textAlign = "center";
			ctx.textBaseline = "middle";
			var alpha = 255;
			if (x == 0 && xNudge < 0) {
				alpha = 1.0+xNudge/(boxSize/2);
			}
			else if (x == 4 && xNudge > 0) {
				alpha = 1.0-xNudge/(boxSize/2);
			}
			if (y == 0 && yNudge < 0) {
				alpha = 1.0+yNudge/(boxSize/2);
			}
			else if (y == 4 && yNudge > 0) {
				alpha = 1.0-yNudge/(boxSize/2);
			}
			if (alpha < 0.0) alpha = 0.0;
			ctx.globalAlpha = alpha;
			ctx.fillStyle = boxes[y][x].colour;
			ctx.fillRect(xPos+xNudge,yPos+yNudge,boxSize, boxSize);
			ctx.globalAlpha = 1.0;
			ctx.fillStyle = "white";
			ctx.fillText(boxes[y][x].letter,xPos+(boxSize/2)+xNudge,yPos+(boxSize/2)+yNudge);
		}
	}

	console.log(drawframes);
	if (drawframes > 0) {
		drawframes--;
		window.cancelAnimationFrame(lastDrawRequestId);
		lastDrawRequestId = window.requestAnimationFrame(draw);
	}
}
</script>
</head>
<body onload='init()' style="width:100%;min-width:100%;margin:0">
	<div style="text-align:center; margin:auto">
		<canvas id="squares" width="420" height="420">
		</canvas>
	</div>
	<div class="footer">
		<div id="history" style="width:100%;overflow-x:auto;overflow-y:hidden;white-space:nowrap;text-align:center;touch-action:pan-x">
		</div>
	</div>
</body>
</html>
