<html>
<head>
<meta name="viewport" content="width=440,initial-scale=0.9,user-scalable=no">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Raleway:wght@600;800&display=swap" rel="stylesheet">
<style>
body {
	touch-action: none;
	font-family: 'Raleway', sans-serif;
}
canvas {
}
p {
	font-size: 20px;
}
.footer {
   position: fixed;
   left: 0;
   bottom: 0;
   width: 100%;
   text-align: center;
}

.win-right { 
	display:inline-block; 
	height:300px; 
	margin-top:60px; 
	margin-bottom:60px; 
	overflow:hidden; 
	transition: width 0.2s;
}
.win-right-shrink {
	width:0px;
}
.win-right-expand {
	width: 160px;
}

.win-down {
	display:inline-block;
	background-color:#eee; 
	height:180px; 
	width:300px;
	overflow:hidden; 
	transition: height 0.2s;
	margin:0;
}
.win-down-shrink {
	height: 0px;
}
.win-down-expand {
	height: 180px;
}
.sharebutton {
	display:inline-block;
	background-color:#2aa617;
	color:#fff;
	font-weight:bold;
	font-size: 20px;
	padding:8px 30px 8px 30px;
	border-radius:5px;
	cursor: pointer;
}
.sharebutton:hover {
	background-color:#3bba27;
}
</style>

<script src="//cdnjs.cloudflare.com/ajax/libs/seedrandom/3.0.5/seedrandom.min.js"></script>
<script src="wordlist.js"></script>
<script>

function findGetParameter(parameterName) {
    var result = null,
        tmp = [];
    location.search
        .substr(1)
        .split("&")
        .forEach(function (item) {
          tmp = item.split("=");
          if (tmp[0] === parameterName) result = decodeURIComponent(tmp[1]);
        });
    return result;
}

const Colour = {
	LightGrey: "#ccc",
	Green: "#2aa617",
	Orange: "#ec721d",
	Yellow: "#ecc61d",
	DarkGrey: "#333",
	MediumGrey: "#777"
}

class Box {
	constructor(letter) {
		this.letter = letter;
		this.colour = Colour.LightGrey;
	}
}
function b(x) { return new Box(x); }

class SaveData {
	constructor() {
		this.today = "";
		this.emojiHistory = "";
		this.colourblind = false;
	}
	saveRow(y) {
		for (let i=0;i<boxes.length;i++) {
			this.emojiHistory += this.boxToEmoji(boxes[y][i]);
		}
		this.emojiHistory += '\n';
		console.log(this.emojiHistory);
		
	}
	saveCol(x) {
		for (let i=0;i<boxes.length;i++) {
			this.emojiHistory += this.boxToEmoji(boxes[i][x]);
		}
		this.emojiHistory += '\n';
		console.log(this.emojiHistory);
	}
	boxToEmoji(box) {
		console.log(box);
		if (box.colour == Colour.Green)    return '\uD83D\uDFE9';
		if (box.colour == Colour.Yellow)   return '\uD83D\uDFE8';
		if (box.colour == Colour.Orange)   return '\uD83D\uDFE7';
		if (box.colour == Colour.DarkGrey) return '\u2B1B';
		return '\u2B1C';
	}
}

var saveData = new SaveData();

var time;
var lastTime;
var ctx;
var boxes;
var memories;
var answer;
var answerSet;

var allValids = legitWords + guesses;

var boxSize = 50;
var boxMargin = 10;

function getOverlapIndices(word1, word2) {
	var word1OverlapIndex = -1;
	var word2OverlapIndex = -1;
	for (let i=0;i<word1.length;i++) {
		for (let j=0;j<word2.length;j++) {
			if (word1[i] == word2[j]) {
				return [i,j];
			}
		}
	}
	return [0,0];
}

function init() {
	ctx = document.getElementById("squares").getContext("2d");
	boxes = 
	[
		[b("A"),b("B"),b("C"),b("D"),b("E")],
		[b("F"),b("G"),b("H"),b("I"),b("J")],
		[b("K"),b("L"),b("M"),b("N"),b("O")],
		[b("P"),b("R"),b("S"),b("T"),b("U")],
		[b("V"),b("W"),b("X"),b("Y"),b("Z")],
	];

	memories = 
	[
		[{},{},{},{},{}],
		[{},{},{},{},{}],
		[{},{},{},{},{}],
		[{},{},{},{},{}],
		[{},{},{},{},{}]
	];

	saveData.today = new Date().toJSON().slice(0,10);
	var rng;
	if (findGetParameter("practice")) {
		rng = new Math.seedrandom();
	} else {
		rng = new Math.seedrandom(saveData.today);
	}

	var word1;
	var word2;
	while (true) {
		word1 = legitWords[Math.abs(rng.int32()) % legitWords.length];
		word2 = legitWords[Math.abs(rng.int32()) % legitWords.length];
		var set1 = new Set(word1);
		var set2 = new Set(word2);

		// check that words don't have duplicate letters
		if (word1.length != set1.size) continue;
		if (word2.length != set2.size) continue;

		// make sure there's only one overlapping letter
		var wordboth = word1+word2;
		answerSet = new Set(wordboth);
		if (wordboth.length != answerSet.size + 1) continue;

		// no q
		if (word1.includes("q")) continue;
		if (word2.includes("q")) continue;

		// if we've made it here, we've got a workable solution
		break;
	}

	var indices = getOverlapIndices(word1, word2);

	answer = 
	[
		[b(""),b(""),b(""),b(""),b("")],
		[b(""),b(""),b(""),b(""),b("")],
		[b(""),b(""),b(""),b(""),b("")],
		[b(""),b(""),b(""),b(""),b("")],
		[b(""),b(""),b(""),b(""),b("")],
	];

	for (let i=0; i<word2.length; i++) {
		answer[indices[0]][i].letter = word2[i];
	}
	for (let i=0; i<word1.length; i++) {
		answer[i][indices[1]].letter = word1[i];
	}

	draw();
}

var clickX;
var clickY;
var mouseX;
var mouseY;
var mouseIsDown;
var columnlock;
var rowlock;
onmousemove = function(e) {
	if (e.touches) {
		mouseX = e.touches[0].clientX;
		mouseY = e.touches[0].clientY;
	} else {
		mouseX = e.clientX;
		mouseY = e.clientY;
	}
	drawframes = 60;
	draw();
}
onmouseup = function(e) {
	mouseIsDown = false;
	drawframes = 60;
	draw();
}

var boxClickedX;
var boxClickedY;
var drawframes = 60;
onmousedown = function(e) {
	if (wonAlready) return;
	columnLock = false;
	rowLock = false;
	var squaresCanvas = document.getElementById("squares");
	console.log(e)
	if (e.srcElement != squaresCanvas) return;

	mouseIsDown = true;
	if (e.touches) {
		clickX = e.touches[0].clientX;
		clickY = e.touches[0].clientY;
	} else {
		clickX = e.clientX;
		clickY = e.clientY;
	}

	var rect = squaresCanvas.getBoundingClientRect();
	var canvasX = clickX - rect.left;
	var canvasY = clickY - rect.top;

	boxClickedX = Math.floor(canvasX / (boxSize + boxMargin)) - 1;
	boxClickedY = Math.floor(canvasY / (boxSize + boxMargin)) - 1;

	if (boxClickedX < 0 || boxClickedY < 0 || boxClickedX > 4 || boxClickedY > 4) {
		mouseIsDown = false;
		boxClickedX = 0;
		boxClickedY = 0;
	}

	mouseX = clickX;
	mouseY = clickY;

	drawframes = 60;
	draw();
}

ontouchstart = onmousedown;
ontouchend = onmouseup;
ontouchmove = onmousemove;

var lastTime;
var mouseWasDown;

function colourFromMemory(i,j) {
	var thisBox = boxes[i][j];
	var thisLetter = thisBox.letter.toLowerCase();
	var memory = memories[i][j][thisLetter];
	if (memory) {
		thisBox.colour = memory;
	}
}

function recolour(i,j) {
	var thisAnswer = answer[i][j];
	var thisBox = boxes[i][j];
	var thisLetter = thisBox.letter.toLowerCase();

	if (thisAnswer.letter == thisLetter) {
		thisBox.colour = Colour.Green;

		for (let k=0; k<boxes.length; k++) {
			for (let l=0; l<boxes.length; l++) {
				memories[k][l][thisLetter] = Colour.DarkGrey;
			}
		}
		for (let k=0; k<boxes.length; k++) {
			memories[i][k][thisLetter] = Colour.Yellow;
		}
		for (let k=0; k<boxes.length; k++) {
			memories[k][j][thisLetter] = Colour.Orange;
		}
		memories[i][j][thisLetter] = thisBox.colour;
		return;
	}

	for (let k=0; k<boxes.length;k++) {
		if (answer[i][k].letter == thisLetter) {
			thisBox.colour = Colour.Yellow;
			for (let q=0; q<boxes.length; q++) {
				memories[q][j][thisLetter] = Colour.DarkGrey;
			}
			memories[i][j][thisLetter] = thisBox.colour;
			return;
		}
	}
	for (let k=0; k<boxes.length;k++) {
		if (answer[k][j].letter == thisLetter) {
			thisBox.colour = Colour.Orange;
			for (let q=0; q<boxes.length; q++) {
				memories[i][q][thisLetter] = Colour.DarkGrey;
			}
			memories[i][j][thisLetter] = thisBox.colour;
			return;
		}
	}
	thisBox.colour = Colour.DarkGrey;
	for (let k=0; k<boxes.length;k++) {
		if (!memories[i][k][thisLetter])
			memories[i][k][thisLetter] = Colour.MediumGrey;
		if (!memories[k][j][thisLetter])
			memories[k][j][thisLetter] = Colour.MediumGrey;
	}
	memories[i][j][thisLetter] = Colour.DarkGrey;
}

function checkRow(y) {
	var word = "";
	for (let i=0; i<boxes.length; i++) {
		word += boxes[y][i].letter;
	}
	word = word.toLowerCase();
	if (allValids.includes(word)) {
		return word;
	}
	return "";
}
function checkCol(x) {
	var word = "";
	for (let i=0; i<boxes.length; i++) {
		word += boxes[i][x].letter;
	}
	word = word.toLowerCase();
	if (allValids.includes(word)) {
		return word;
	}
	return "";
}

var wonAlready = false;
var photo = 0;
var takenPhotos = new Set();
function update() {
	/*
	var dt = (Date.now() - lastTime) / 1000;
	lastTime = Date.now();
	if (isNaN(dt))
	{
		return;
	};
   */

	if (mouseWasDown && !mouseIsDown) {
		// handle mouse-unclicked things

		if (rowlock) {
			// check the row that just moved
			var checkedRow = checkRow(boxClickedY);
			if (checkedRow) {
				for (let i=0; i<boxes.length; i++) {
					recolour(boxClickedY,i);
				}
				checkedRow += "r" + boxClickedY;
				if (!takenPhotos.has(checkedRow)) {
					takenPhotos.add(checkedRow);
					photo = 5;
					saveData.saveRow(boxClickedY);
				}
			} else {
				for (let i=0; i<boxes.length; i++) {
					boxes[boxClickedY][i].colour = "#ccc";
				}
			}
			// check the columns
			for (let i=0; i<boxes.length; i++) {
				var checkedCol = checkCol(i);
				if (checkedCol) {
					for (let k=0; k<boxes.length; k++) {
						recolour(k,i);
					}
					checkedCol += "c" + i;
					if (!takenPhotos.has(checkedCol)) {
						takenPhotos.add(checkedCol);
						photo = 5;
						saveData.saveCol(i);
					}
				}
			}
		}
		else if (columnlock) {
			// check the column that just moved
			var checkedCol = checkCol(boxClickedX);
			if (checkedCol) {
				for (let i=0; i<boxes.length; i++) {
					recolour(i,boxClickedX);
				}
				checkedCol += "c" + boxClickedX;
				if (!takenPhotos.has(checkedCol)) {
					takenPhotos.add(checkedCol);
					photo = 5;
					saveData.saveCol(boxClickedX);
				}
			} else {
				for (let i=0; i<boxes.length; i++) {
					boxes[i][boxClickedX].colour = "#ccc";
				}
			}
			// check the rows
			for (let i=0; i<boxes.length; i++) {
				var checkedRow = checkRow(i);
				if (checkedRow) {
					for (let k=0; k<boxes.length; k++) {
						recolour(i,k);
					}
					checkedRow += "r" + i;
					if (!takenPhotos.has(checkedRow)) {
						takenPhotos.add(checkedRow);
						photo = 5;
						saveData.saveRow(i);
					}
				}
			}
		}

		for (let i=0; i<boxes.length; i++) {
			for (let j=0; j<boxes.length; j++) {
				colourFromMemory(i,j);
			}
		}

		if (!wonAlready) {
			var won = true;
			for (let i=0; i<boxes.length; i++) {
				for (let j=0; j<boxes.length; j++) {
					var answerletter = answer[i][j].letter;
					if (!answerletter) continue;
					var currentletter = boxes[i][j].letter.toLowerCase();
					if (currentletter != answerletter) 
					{
						won = false;
					}
				}
			}
			if (won) {
				photo = 5;
				wonAlready = true;
				win();
			}
		}

		rowlock = false;
		columnlock = false;
	}
	mouseWasDown = mouseIsDown;

	if (photo > 0) {
		photo--;
		if (photo == 1) {
			photo = 0;
			var squares = document.getElementById("squares");
			var history = document.getElementById("history");
			var newCanvas = document.createElement("canvas");
			newCanvas = history.appendChild(newCanvas);
			newCanvas.setAttribute("width","240");
			newCanvas.setAttribute("height","240");
			newCanvas.getContext("2d").drawImage(squares,0,0,240,240);
			history.scrollLeft = history.scrollWidth;
		}
	}

	if (mouseIsDown && !columnlock && !rowlock) {
		if (Math.abs(clickX-mouseX) > 0.2*boxSize) {
			rowlock = true;
		}
		else if (Math.abs(clickY-mouseY) > 0.2*boxSize) {
			columnlock = true;
		}
	}

	if (columnlock) {
		yNudge = mouseY - clickY;
		while (yNudge > 0.6*boxSize) {
			clickY += boxSize + boxMargin;
			var jumpbox = boxes[4][boxClickedX];
			boxes[4][boxClickedX] = boxes[3][boxClickedX];
			boxes[3][boxClickedX] = boxes[2][boxClickedX];
			boxes[2][boxClickedX] = boxes[1][boxClickedX];
			boxes[1][boxClickedX] = boxes[0][boxClickedX];
			boxes[0][boxClickedX] = jumpbox;
			yNudge = mouseY - clickY;
		}
		while (yNudge < -0.6*boxSize) {
			clickY -= boxSize + boxMargin;
			var jumpbox = boxes[0][boxClickedX];
			boxes[0][boxClickedX] = boxes[1][boxClickedX];
			boxes[1][boxClickedX] = boxes[2][boxClickedX];
			boxes[2][boxClickedX] = boxes[3][boxClickedX];
			boxes[3][boxClickedX] = boxes[4][boxClickedX];
			boxes[4][boxClickedX] = jumpbox;
			yNudge = mouseY - clickY;
		}
	}
	else if (rowlock) {
		xNudge = mouseX - clickX;
		while (xNudge > 0.6*boxSize) {
			clickX += boxSize + boxMargin;
			var jumpbox = boxes[boxClickedY][4];
			boxes[boxClickedY][4] = boxes[boxClickedY][3];
			boxes[boxClickedY][3] = boxes[boxClickedY][2];
			boxes[boxClickedY][2] = boxes[boxClickedY][1];
			boxes[boxClickedY][1] = boxes[boxClickedY][0];
			boxes[boxClickedY][0] = jumpbox;
			xNudge = mouseX - clickX;
		}
		while (xNudge < -0.6*boxSize) {
			clickX -= boxSize + boxMargin;
			var jumpbox = boxes[boxClickedY][0];
			boxes[boxClickedY][0] = boxes[boxClickedY][1];
			boxes[boxClickedY][1] = boxes[boxClickedY][2];
			boxes[boxClickedY][2] = boxes[boxClickedY][3];
			boxes[boxClickedY][3] = boxes[boxClickedY][4];
			boxes[boxClickedY][4] = jumpbox;
			xNudge = mouseX - clickX;
		}
	}
}

var lastDrawRequestId = 0;
function draw() {
	
	update();

	ctx.fillStyle = "white";
	ctx.fillRect(0,0,ctx.canvas.width, ctx.canvas.height);

	for (let y=0; y<boxes.length;++y) {
		for (let x=0; x<boxes[y].length;++x) {

			var xPos = (x+1)*(boxSize+boxMargin);
			var yPos = (y+1)*(boxSize+boxMargin);

			var xNudge = 0;
			var yNudge = 0;

			if (columnlock && x == boxClickedX) {
				yNudge = mouseY - clickY;
			}
			if (rowlock && y == boxClickedY) {
				xNudge = mouseX - clickX;
			}

			ctx.font = "bold 32px Raleway";
			ctx.textAlign = "center";
			ctx.textBaseline = "middle";
			var alpha = 255;
			if (x == 0 && xNudge < 0) {
				alpha = 1.0+xNudge/(boxSize/2);
			}
			else if (x == 4 && xNudge > 0) {
				alpha = 1.0-xNudge/(boxSize/2);
			}
			if (y == 0 && yNudge < 0) {
				alpha = 1.0+yNudge/(boxSize/2);
			}
			else if (y == 4 && yNudge > 0) {
				alpha = 1.0-yNudge/(boxSize/2);
			}
			if (alpha < 0.0) alpha = 0.0;
			ctx.globalAlpha = alpha;
			ctx.fillStyle = boxes[y][x].colour;

			var xSquish = 0;
			var ySquish = 0;
			if (saveData.colourblind) {
				if (boxes[y][x].colour == Colour.LightGrey || boxes[y][x].colour == Colour.DarkGrey || boxes[y][x].colour == Colour.MediumGrey) {
					xSquish = 6;
					ySquish = 6;
				}
				else if (boxes[y][x].colour == Colour.Yellow) {
					xSquish = -6;
					ySquish = 16;
				}
				else if (boxes[y][x].colour == Colour.Orange) {
					xSquish = 16;
					ySquish = -6;
				}
				else if (boxes[y][x].colour == Colour.Green) {
					xSquish = -4;
					ySquish = -4;
				}
			}

			ctx.fillRect(xPos+xNudge+(xSquish/2),yPos+yNudge+(ySquish/2),boxSize-xSquish, boxSize-ySquish);
			ctx.globalAlpha = 1.0;
			ctx.fillStyle = "white";
			ctx.fillText(boxes[y][x].letter,xPos+(boxSize/2)+xNudge,yPos+(boxSize/2)+yNudge);
		}
	}

	if (drawframes > 0) {
		drawframes--;
		window.cancelAnimationFrame(lastDrawRequestId);
		lastDrawRequestId = window.requestAnimationFrame(draw);
	}
}

function win() {
	var winbox;
	var wordcount;
	var guesses = saveData.emojiHistory.split("\n").length-1;
	if (document.documentElement.clientHeight > 850) {
		// we've got room for the vertical box
		winbox = document.getElementById("win-down");
		winbox.classList.remove("win-down-shrink");
		winbox.classList.add("win-down-expand");
		wordcount = document.getElementById("wordcount2");
		wordcount.innerHTML = guesses.toString();
	} else {
		winbox = document.getElementById("win-right");
		winbox.classList.remove("win-right-shrink");
		winbox.classList.add("win-right-expand");
		wordcount = document.getElementById("wordcount");
		wordcount.innerHTML = guesses.toString();
	}


}

function share() {
	var guesses = saveData.emojiHistory.split("\n").length-1;
	var sharestring = "Daily Slidle " + saveData.today + " - " + guesses + "\n";
	sharestring += saveData.emojiHistory;
	navigator.clipboard.writeText(sharestring).then(() => {
		alert("Copied to clipboard!");
	})
}

function secondTimer() {
	var now = new Date();
	var midnight = new Date();
	midnight.setDate(now.getDate()+1);
	midnight.setHours(0,0,0);

	var distance = midnight - now;

	var hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
	var minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
	var seconds = Math.floor((distance % (1000 * 60)) / 1000);
	var timertext = hours.toString().padStart(2,"0") + ":" + minutes.toString().padStart(2,"0") + ":" + seconds.toString().padStart(2,"0")

	var timer1 = document.getElementById("timer");
	timer1.innerHTML = timertext;
	var timer2 = document.getElementById("timer2");
	timer2.innerHTML = timertext;

}
setInterval(secondTimer, 1000);
</script>
</head>
<body onload='init()' style="width:100%;min-width:100%;margin:0">
	<div style="text-align:center; margin:auto;">
		<div style="height:420px">
			<canvas id="squares" width="420" height="420" style="display:inline-block;">
			</canvas>
			<div id="win-right" class="win-right win-right-shrink">
				<!-- Why is vertical centering in css this hard -->
				<!-- I give up, I'm just using a table -->
				<table style="width:160px;";>
					<tr style="text-align:center; vertical-align: middle">
						<td style="height:300px; width:160px; background-color:#eee">
							<div style="line-height:1.5">
								<p><span style="font-weight:bold">COMPLETE!</span><br />
								<span id="wordcount">0</span> words used.</p>
								<p>Next Slidle in<br />
								<span id="timer">10:30:08</span></p>
								<div class="sharebutton" onclick="share()">SHARE</div>
							</div>
						</td>
				</tr>
				</table>
			</div>
		</div>
	</div>
	<div style="text-align:center; margin:auto;">
		<div id="win-down" class="win-down win-down-shrink">
							<div style="line-height:1.0">
								<p><span style="font-weight:bold">COMPLETE!</span><br />
								<span id="wordcount2">0</span> words used.</p>
								<p>Next Slidle in <span id="timer2">10:30:08</span></p>
								<div class="sharebutton" onclick="share()">SHARE</div>
							</div>
		</div>
	</div>
	<div class="footer">
		<div id="history" style="width:100%;overflow-x:auto;overflow-y:hidden;white-space:nowrap;text-align:center;touch-action:pan-x">
		</div>
	</div>
</body>
</html>
